/**
 * TextExportService
 * 
 * Service for exporting sessions to plain text format.
 * Infrastructure layer - implements IExportService.
 */

import { IExportService, ExportOptions, ExportResult } from '../../../domain/services/IExportService.js';
import { Session } from '../../../domain/entities/Session.js';
import * as fs from 'fs/promises';
import * as path from 'path';

export class TextExportService implements IExportService {
  /**
   * Export a session to a text file
   */
  async export(session: Session, outputPath: string, options?: ExportOptions): Promise<ExportResult> {
    try {
      // Ensure output directory exists
      const outputDir = path.dirname(outputPath);
      await fs.mkdir(outputDir, { recursive: true });

      // Build the text content
      const content = this.buildTextContent(session, options);

      // Write to file
      await fs.writeFile(outputPath, content, 'utf-8');

      return {
        success: true,
        filePath: outputPath,
        format: 'txt'
      };
    } catch (error) {
      return {
        success: false,
        filePath: outputPath,
        format: 'txt',
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Build the text content for export
   */
  private buildTextContent(session: Session, options?: ExportOptions): string {
    const lines: string[] = [];
    const includeMetadata = options?.includeMetadata !== false;
    const includeTranscription = options?.includeTranscription !== false;
    const includeNotes = options?.includeNotes !== false;
    const includeTimestamps = options?.includeTimestamps !== false;

    // Title
    lines.push('='.repeat(80));
    lines.push(session.title.toUpperCase());
    lines.push('='.repeat(80));
    lines.push('');

    // Metadata section
    if (includeMetadata) {
      lines.push('METADATA');
      lines.push('-'.repeat(80));
      lines.push(`Session ID: ${session.id}`);
      lines.push(`Created: ${this.formatDate(session.createdAt)}`);
      lines.push(`Updated: ${this.formatDate(session.updatedAt)}`);
      lines.push(`Duration: ${this.formatDuration(session.duration)}`);
      
      if (session.tags.length > 0) {
        lines.push(`Tags: ${session.tags.join(', ')}`);
      }
      
      lines.push('');
    }

    // Transcription section
    if (includeTranscription && session.hasTranscription() && session.transcription) {
      lines.push('TRANSCRIPTION');
      lines.push('-'.repeat(80));
      
      if (includeTimestamps && session.transcription.segments.length > 0) {
        // Include timestamped segments
        for (const segment of session.transcription.segments) {
          const timestamp = this.formatTimestamp(segment.startTime);
          const confidence = segment.confidence 
            ? ` (${(segment.confidence * 100).toFixed(1)}%)`
            : '';
          lines.push(`[${timestamp}]${confidence} ${segment.text}`);
        }
      } else {
        // Just include the full text
        lines.push(session.transcription.fullText);
      }
      
      lines.push('');
      
      // Transcription metadata
      if (includeMetadata) {
        lines.push(`Provider: ${session.transcription.provider}`);
        lines.push(`Language: ${session.transcription.language}`);
        if (session.transcription.averageConfidence !== undefined) {
          lines.push(`Average Confidence: ${(session.transcription.averageConfidence * 100).toFixed(1)}%`);
        }
        lines.push('');
      }
    }

    // Notes section
    if (includeNotes && session.notes.trim().length > 0) {
      lines.push('NOTES');
      lines.push('-'.repeat(80));
      // Strip HTML tags from notes
      const plainNotes = this.stripHtml(session.notes);
      lines.push(plainNotes);
      lines.push('');
    }

    // Export history
    if (includeMetadata && session.exportHistory.length > 0) {
      lines.push('EXPORT HISTORY');
      lines.push('-'.repeat(80));
      for (const exportRecord of session.exportHistory) {
        lines.push(`${this.formatDate(exportRecord.exportedAt)} - ${exportRecord.format.toUpperCase()} - ${exportRecord.path}`);
      }
      lines.push('');
    }

    // Footer
    lines.push('='.repeat(80));
    lines.push(`Exported: ${this.formatDate(new Date())}`);
    lines.push('Generated by ScribeCat v2');
    lines.push('='.repeat(80));

    return lines.join('\n');
  }

  /**
   * Format a date for display
   */
  private formatDate(date: Date): string {
    return date.toLocaleString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  /**
   * Format duration in seconds to readable format
   */
  private formatDuration(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
      return `${hours}h ${minutes}m ${secs}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${secs}s`;
    } else {
      return `${secs}s`;
    }
  }

  /**
   * Format timestamp in seconds to MM:SS or HH:MM:SS
   */
  private formatTimestamp(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
  }

  /**
   * Strip HTML tags from text
   */
  private stripHtml(html: string): string {
    return html
      .replace(/<[^>]*>/g, '') // Remove HTML tags
      .replace(/&nbsp;/g, ' ') // Replace &nbsp; with space
      .replace(/&amp;/g, '&') // Replace &amp; with &
      .replace(/&lt;/g, '<') // Replace &lt; with <
      .replace(/&gt;/g, '>') // Replace &gt; with >
      .replace(/&quot;/g, '"') // Replace &quot; with "
      .trim();
  }

  /**
   * Get the supported export format
   */
  getFormat(): 'txt' | 'pdf' | 'docx' | 'html' {
    return 'txt';
  }

  /**
   * Check if the service is available
   */
  async isAvailable(): Promise<boolean> {
    // Text export is always available (no external dependencies)
    return true;
  }
}
